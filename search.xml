<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gerunds and Infinitives]]></title>
    <url>%2Fp%2F5e25.html</url>
    <content type="text"></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Grammer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prj Web Chat]]></title>
    <url>%2Fp%2F509e.html</url>
    <content type="text"><![CDATA[Members YolandaW Xuejun LIU PrinceZiqi]]></content>
      <categories>
        <category>Event-drive Asynochronous Programming</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>JS</tag>
        <tag>Prj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TP1 Mandelbrot Set Fractal]]></title>
    <url>%2Fp%2Fa353.html</url>
    <content type="text"><![CDATA[Prepare your project Node.jsInstall node from the official website: https://nodejs.org.Create a new folder and add an app.js script, whose contents are as follows:1console.log("Hello World") Open a new terminal and locate it in your project folder.Launch your application with the command: node app.js We will configure the project in npm, thanks to the command npm init. You will answer the different questions. Complex numbersWe will create a small class to encapsulate and manipulate complex numbers, which will meet the needs of the TP suite. Resume and complete the following Complex class. None of the methods of the Complex class should alter the fields this.re and this.im. Complex objects that they return are therefore always new instances. 1234567891011121314151617181920212223class Complex &#123;constructor (re, im) &#123;this.re = rethis.im = im&#125;/** @return Complex le carré du complexe this*/square () &#123; /*...*/ &#125;/** @param &#123;Complex&#125; second à sommer à this* @return Complex la somme this + second*/sum (second) &#123; /*...*/ &#125;/** @return Number le module du complexe this*/module () &#123; /*...*/ &#125;&#125; To test that the library works:123456var c1 = new Complex(0, 1)console.log("|c1| = " + c1.module())console.log("c1 * c1 = " + JSON.stringify(c1.square()))var c2 = new Complex(1, 0)console.log("c1 + c2 = " + JSON.stringify(c1.sum(c2))) What should display at runtime: |c1| = 1c1 * c1 = {“re”:-1,”im”:0}c1 + c2 = {“re”:1,”im”:1} Notes: Complex operation A complex number is a number that can be expressed in the form $ z = x + iy $, where $ x $ and $ y $ are real numbers, and $ i $ is a solution of the equation $ x^2 = −1 $. It can also be expressed in polar form as $ z=re^{i\varphi} $. The sum$ z_1+z_2=(x_1+x_2)+i(y_1+y_2) $ The moduleIn this way, $ r=|z| $, and $ x=rcos\varphi $, $ y=rsin\varphi $.So we can get $ |z|=\sqrt{x^2+y^2} $ The square$ z^2=(x+iy)^2=x^2+i2xy+(iy)^2=(x^2-y^2)+i2xy $ 1234567891011121314151617181920212223242526272829303132333435363738394041//Complex numbersclass Complex &#123;constructor(re, im) &#123;this.re = rethis.im = imreturn this&#125;/*get the square of this complex number* @method square()* @return &#123;Complex&#125; the square of this complex*/square() &#123;var squ=new Complex()squ.re= this.re * this.re - this.im * this.imsqu.im = 2 * this.re * this.imreturn squ&#125;/*get the sum of this complex number and the second one* @method sum(second)* @param second&#123;Complex&#125; to summon this* @return &#123;Complex&#125; the sum this + second*/sum(second) &#123;var summ=new Complex()summ.re = this.re + second.resumm.im = this.im + second.imreturn summ&#125;/*get the module of this complex* @method module()* @return &#123;Number&#125; the module of this complex*/module() &#123;var Number = Math.sqrt(this.im * this.im + this.re * this.re)return Number&#125;&#125; Read a number from the consoleThe readline module (integrated with node) is used to manipulate flows, read one line at a time. Among these flows, one can access those of the console (process.stdin, process.stdout). Here is what the official documentation gives us:1234567891011121314const readline = require('readline')const rl = readline.createInterface(&#123;input: process.stdin,output: process.stdout&#125;)rl.question('What do you think of Node.js? ', (answer) =&gt; &#123;// TODO: Log the answer in a databaseconsole.log('Thank you for your valuable feedback:', answer)rl.close()&#125;)//https://nodejs.org/api/readline.html#readline_readline To convert a string to a number: parseInt (string) or Number (string)Design a program with the following behavior (question + confirmation): Size of the image to generate? 128Choice of dimensions: 128x128px Notes: JS readline.Interface module When the code is called, the Node.js program does not terminate until readline.Interface is closed because the interface is waiting for data to be received in the input stream. 12345678910111213const readline = require('readline')const rl = readline.createInterface(&#123;input: process.stdin,output: process.stdout&#125;)rl.question('Size of the image to generate? ', (size) =&gt; &#123;// TODO: Log the answer in a databasevar imsize = size + " x " + size + " px"console.log('Choice of dimensions:', imsize)rl.close()&#125;) Compare require/import/export in JS CommonJS &amp; AMD use require to use module Notes: Asyn event the second question on console 123456789101112131415161718192021222324252627282930313233343536373839404142434445'use strict'const readline = require('readline')const rl = readline.createInterface(&#123;input: process.stdin,output: process.stdout&#125;)const question1 = () =&gt; &#123;return new Promise((resolve, reject) =&gt; &#123;rl.question('Size of the image to generate? ', (size) =&gt; &#123;//input controlif ((/^\d+$/.test(size)) &amp;&amp; (size &gt; 0) &amp;&amp; (size &lt;= 1080)) &#123;console.log('Choice of dimensions:' + size + " x " + size + " px")//size&#123;String&#125; are all numbers and size is in [1,1080] integerreturn resolve(size)&#125; else &#123;resolve(question1())&#125;&#125;)&#125;)&#125;const question2 = () =&gt; &#123;return new Promise((resolve, reject) =&gt; &#123;rl.question('Image Name? ', (name) =&gt; &#123;console.log(name+".png on DESKTOP")return resolve(name)&#125;)&#125;)&#125;const main = async () =&gt; &#123;var size = await question1()var name = await question2()console.log(name+".png: "+size+" x "+size+" px")//rl.close()&#125;main() Generate a random imageThanks to the jimp library, we will be able to create and save images. The dimension will be requested thanks to the previous question. To install jimp: npm install jimp –save. The dependency is installed and referenced in package.json. Here are some excerpts from the documentation to manipulate the library:1234567891011121314151617181920const Jimp = require("jimp")// open a file called "lenna.png"Jimp.read("lenna.png", function (err, image) &#123;if (err) throw errimage.write("lena-small-bw.jpg") // save&#125;)var image = new Jimp(256, 256)image.getPixelColor(x, y) // colour of that pixel e.g. 0xFFFFFFFFimage.setPixelColor(hex, x, y) // sets the colour of that pixel// e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF Jimp.rgbaToInt(r, g, b, a)// e.g. converts 0xFFFFFFFF to &#123;r: 255, g: 255, b: 255, a:255&#125; Jimp.intToRGBA(hex)//https://www.npmjs.com/package/jimp Pixels have 4 components (red, green, blue and alpha). Alpha at 255 equals a fully opaque color, 0 at a transparent color. Alpha is of low weight in hexadecimal writing. The Math.random() function returns a pseudo random number between 0 and 1 excluded. Design a getRandomPixel() function that returns a hexadecimal color at random, but with an alpha component = 255. Design the buildRandomImage (size, name) function that takes parameters in pixels and the name to save the image to disk. You will call this function inside the callback passed to readline.question(cb). After running your program, you should get an image similar to the example shown here (size: 128px). Notes:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849'use strict'/* get a random int number in [minNum,maxNum] in hexadecimal String* @method randomNum()* @param minNum&#123;Integer&#125;* @param maxNum&#123;Integer&#125;* @return &#123;String&#125; (hexadecimal)*/function randomNum(minNum, maxNum) &#123;var num = parseInt(Math.random() * (maxNum - minNum + 1) + minNum, 10)if (num &lt; 16) &#123;//if the number is just in one bit, add a 0 in high-order position ("e"-&gt;"0e")num = '0' + num.toString(16) &#125; else &#123;num=num.toString(16)&#125;return num; &#125;/* get a random rgb pixel color with 255 alpha * @method getRandomPixel()* @return &#123;String&#125; (hexadecimal and start with '0x')*/function getRandomPixel() &#123;var R = randomNum(0, 255)var G = randomNum(0, 255)var B = randomNum(0, 255)return '0x'+R+G+B+'ff' //with 255 alpha&#125;/* get a random picture in size x size px with 255 alpha RGBA PNG on DeskTop* @method buildRandomPixel()* @param size* @param name image name(without)*/function buildRandomImage(size, name) &#123;const DESKTOP_URL = "C:\\Users\\YolandaW\\Desktop\\"//Generate a random imageconst Jimp = require("jimp")var image = new Jimp(size, size) for ( i = 0; i &lt; size ; i++) &#123;for ( j = 0; j &lt; size; j++) &#123;image.setPixelColor(parseInt(getRandomPixel()), i, j) // sets the colour of that pixel&#125;&#125;name = name + ".png" //save on Desktopimage.write(DESKTOP_URL+name) //save image &#125;buildRandomImage(256, "image") After combine two question together 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091'use strict'const readline = require('readline')const rl = readline.createInterface(&#123;input: process.stdin,output: process.stdout&#125;)const askImageSize = () =&gt; &#123;return new Promise((resolve, reject) =&gt; &#123;rl.question('Size of the image to generate? ', (size) =&gt; &#123;//input controlif ((/^\d+$/.test(size)) &amp;&amp; (size &gt; 0) &amp;&amp; (size &lt;= 1080)) &#123;console.log('Choice of dimensions:' + size + " x " + size + " px")//size&#123;String&#125; are all numbers and size is in [1,1080] integerreturn resolve(size)&#125; else &#123;resolve(askImageSize())&#125;&#125;)&#125;)&#125;const askImageName = () =&gt; &#123;return new Promise((resolve, reject) =&gt; &#123;rl.question('Image Name? ', (name) =&gt; &#123;console.log(name+".png on DESKTOP")return resolve(name)&#125;)&#125;)&#125;/* get a random int number in [minNum,maxNum] in hexadecimal String* @method randomNum()* @param minNum&#123;Integer&#125;* @param maxNum&#123;Integer&#125;* @return &#123;String&#125; (hexadecimal)*/function randomNum(minNum, maxNum) &#123;var num = parseInt(Math.random() * (maxNum - minNum + 1) + minNum, 10)if (num &lt; 16) &#123;//if the number is just in one bit, add a 0 in high-order position ("e"-&gt;"0e")num = '0' + num.toString(16)&#125; else &#123;num = num.toString(16)&#125;return num;&#125;/* get a random rgb pixel color with 255 alpha * @method getRandomPixel()* @return &#123;String&#125; (hexadecimal and start with '0x')*/function getRandomPixel() &#123;var R = randomNum(0, 255)var G = randomNum(0, 255)var B = randomNum(0, 255)return '0x' + R + G + B + 'ff' //with 255 alpha&#125;/* get a random picture in size x size px with 255 alpha RGBA PNG on DeskTop* @method buildRandomPixel()* @param size* @param name image name(without)*/function buildRandomImage(size, name) &#123;const DESKTOP_URL = "C:\\Users\\YolandaW\\Desktop\\"//Generate a random imageconst Jimp = require("jimp")var image = new Jimp(size, size)for (var i = 0; i &lt; size; i++) &#123;for (var j = 0; j &lt; size; j++) &#123;image.setPixelColor(parseInt(getRandomPixel()), i, j) // sets the colour of that pixel&#125;&#125;name = name + ".png" //save on Desktopimage.write(DESKTOP_URL + name) //save image &#125;const main = async () =&gt; &#123;var size = await askImageSize()var name = await askImageName()buildRandomImage(size, name)console.log(name + ".png: " + size + " x " + size + " px has been created on DESKTOP")//rl.close()&#125;main() Notes: different image form PNG、JPNotes: read/write imageNotes: JS comments and How to name methodA fractal in shades of grayThe sought-after fractal is Mandelbrot’s fractal. The color of each pixel is calculated as a function of the divergence rate of a complex recursive sequence. For each pixel, we set a number $ C = x + iy $, with x and y the coordinates of the standardized pixel between 0 and 1. To normalize, divide the usual coordinates by the size of each dimension. The recurrence formula is: $ Z_n = (Z_{n-1})^2 + C $ $ Z_n $ is a rank n term of a complex suite $ Z_0 = 0 + i0 = 0 $ $ C $ is a complex constant, added to each recursion and linked to the pixel We consider that the series diverges as soon as the modulus of a term exceeds 2. When a divergence is detected, we return n, the rank from which $ | Z_n | &gt; 2 $. We calculate at most 20 terms: beyond, we suppose that the sequence converges and we return 20. We give the algorithm in algorithmic language. Translate it as a function getMandelbrotDivergenceSpeed (Complex): Number. SpeedDevergence (c: Complex): integerData:c: Complex, the coordinates of a pixel such as $(c.re, c.im)$ $E [0,1] ^2$Local variable:z: Complex, the term of the sequence $Z$ at rank $n$Local variable:n: integer the currently calculated rank Result:Returns the rank $[0, 19]$ from which the divergence is found or $20$ otherwise beginning $z ← Complex (0, 0)$ $n ← 0$ as long as $n &lt;20 $ repeat $z ← z * z + c$ if $ z.module ()&gt; 2 $ then return $ n $ $n ← n + 1$ end as long as return $20$ end Design a function coordToComplex (x, y, size): Complex Very simple that accepts two coordinates (x, y) as well as the size of the image and returns a complex c such that: c.re be x normalized between 0 and 1 c.im is normalized between 0 and 1 Design a speedToGrey (n): Number function that takes a divergence rate parameter and returns a fully opaque gray hue in hexadecimal such as: n = 0 returns white. n = 20 returns black. Design a buildGreyFractal (size, name) function that takes parameters in pixels and the name to save the image to disk. See the entire fractalCurrently, you only see a quarter of the fractal. Why? Because we associate with our pixel coordinates strictly positive values. For example, on an image of 128x128px: currently the pixel (0,0) is transformed into Complex (0, 0) the pixel (128, 128) is transformed into Complex (1, 1) in the version that you will improve the pixel (0, 0) is transformed into Complex (-1, -1) the pixel (64, 64) is transformed into Complex (0, 0) the pixel (128, 128) is transformed into Complex (1, 1) Get such behavior only changing the function coordToComplex (x, y, size). Go further on the manipulation of coordinatesIf you still have time at the end of the session, you can tackle the following issues: choose the zoom to apply choose a translation to apply choose a rotation to apply choose a stretch on each of the dimensions A fractal in colorTo enjoy your fractal in color, you can use the following function12345678910111213141516171819202122232425262728293031function speedToColor (n) &#123;n = Math.min(n / 50, 1)let s = 1let l = 0.6, r, g, bif (s === 0) &#123;r = g = b = l // achromatic&#125; else &#123;function hue2rgb(p, q, t) &#123;if(t &lt; 0) t += 1if(t &gt; 1) t -= 1if(t &lt; 1/6) return p + (q - p) * 6 * tif(t &lt; 1/2) return qif(t &lt; 2/3) return p + (q - p) * (2/3 - t) * 6return p&#125;var q = l &lt; 0.5 ? l * (1 + s) : l + s - l * svar p = 2 * l - qr = hue2rgb(p, q, n + 1/3)g = hue2rgb(p, q, n)b = hue2rgb(p, q, n - 1/3)&#125;return Jimp.rgbaToInt(Math.round(r * 255),Math.round(g * 255),Math.round(b * 255),255)&#125; Of course, this is just one example of functions that can turn speed into color. You can design more original ones if you wish. Smooth iterhttp://blog.miskcoo.com/2016/10/mandelbrot-set]]></content>
      <categories>
        <category>Event-drive Asynochronous Programming</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>JS</tag>
        <tag>TP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event-drive Asynochronous Programming]]></title>
    <url>%2Fp%2F2e74.html</url>
    <content type="text"><![CDATA[SyntaxDeclaration: var\const\letOnly use let except you know it would never change.A variable declared with var whose scope is within the function in which the statement is located, and there is a variable promotion phenomenon;A variable declared with let whose scope is within the code block in which the statement is located, and there is no variable promotion;The use of const declares a const, and the value of the constant cannot be modified in the code that appears later. === c.f. ==Always use=== unless you have specially reason to use ==, it.=== will check both value and type. from Zhihu@BelleveRed：===Orange：==Yellow：&lt;= and &gt;= established，== not establishedBlue：only &gt;= establishedGreen：only &lt;= established Template String ${var}123456var firstName = 'Jake';var lastName = 'Rawr';//normal Stringconsole.log('My name is ' + firstName + ' ' + lastName);//Template Stringconsole.log(`My name is $&#123;firstName&#125; $&#123;lastName&#125;`); Fuctions and arrow funcitons1234567891011121314151617fuction inc1=1(n)&#123;return n + 1&#125;const inc2=function(n)&#123;return n+1&#125;const inc3=(n)=&gt;&#123;return n+1&#125;const inc4=n=&gt;n+4//they are all same.fucntion adder(inc) &#123;return (n)=&gt;n+inc&#125;const addOne=adder(1)const addTwo=adder(2)let a=addOne(5)//a=6let b=addTwo(5)//b=7let c=adder(2)(1)//c=3 //use pointers to point the functions' addres . JavaScript Scope （作用域）: Fuction-levelIn JS there are two types of scope: Local scope and Global scopeJavaScript has function scope: Each function creates a new scope. The traditional C-like language, whose scope is block-level scope, curly brackets{} are a scope. But for JavaScript, its scope is a function-level scope, such as an if conditional statement, which is not an independent scope:12345678910111213141516171819var x = 1;console.log(x); // 1if (true) &#123;var x = 2;console.log(x); // 2&#125;console.log(x); // 2//Create a temporary scope from a self-executing functionfunction foo() &#123;var x = 1;if (x) &#123;(function () &#123;var x = 2;// some other code&#125;());&#125;// x is still 1.&#125; Event-drive and AsynchronousThere is only one main thread in JS engine. When it is executing JS code block, other code block are not allowed to be executed, but the code block of event machine and callback will be added into task queue (or called stack).This event or callback function will be executed when a trigger meet the event or callback. Callbackscallbacks are historically the only way to deal with functions that return a result asynchronously. PromiseA Promise is in one of these states: pending: initial state, neither fulfilled nor rejected. fulfilled: meaning that the operation completed successfully. rejected: meaning that the operation failed.]]></content>
      <categories>
        <category>Event-drive Asynochronous Programming</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>JS</tag>
        <tag>Asyn</tag>
      </tags>
  </entry>
</search>
